/**
 * CloudFormation Generator Plugin
 * Converts Abstract IR to CloudFormation YAML/JSON
 */

import {
  GeneratorPlugin,
  GenerateContext,
  GenerateResult,
  GenerateError,
  UnsupportedFeature,
} from '../core/plugin';
import {
  IRDocument,
  IRResource,
  IRVariable,
  IROutput,
  IRModule,
  IRExpression,
  IRValue,
} from '../core/ir';

/**
 * CloudFormation generator plugin
 */
export class CloudFormationGenerator implements GeneratorPlugin {
  languageName = 'cloudformation';
  fileExtension = '.yaml';

  generate(ir: IRDocument, context: GenerateContext): GenerateResult {
    const errors: GenerateError[] = [];
    const warnings: GenerateError[] = [];
    const unsupportedFeatures: UnsupportedFeature[] = [];

    try {
      const cfTemplate: any = {
        AWSTemplateFormatVersion: '2010-09-09',
        Description: 'Generated by IAC Translator',
      };

      // Generate Parameters from variables
      if (ir.variables.length > 0) {
        cfTemplate.Parameters = {};
        for (const variable of ir.variables) {
          try {
            const param = this.generateParameter(variable);
            cfTemplate.Parameters[this.toCFName(variable.name)] = param;
          } catch (error) {
            errors.push({
              message: `Failed to generate parameter for variable ${variable.name}: ${error instanceof Error ? error.message : 'Unknown error'}`,
              severity: 'error',
            });
          }
        }
      }

      // Generate Resources
      if (ir.resources.length > 0) {
        cfTemplate.Resources = {};
        for (const resource of ir.resources) {
          try {
            const cfResource = this.generateResource(resource, unsupportedFeatures);
            cfTemplate.Resources[this.toCFName(resource.name)] = cfResource;
          } catch (error) {
            errors.push({
              message: `Failed to generate resource ${resource.name}: ${error instanceof Error ? error.message : 'Unknown error'}`,
              severity: 'error',
            });
          }
        }
      }

      // Generate Outputs
      if (ir.outputs.length > 0) {
        cfTemplate.Outputs = {};
        for (const output of ir.outputs) {
          try {
            const cfOutput = this.generateOutput(output);
            cfTemplate.Outputs[this.toCFName(output.name)] = cfOutput;
          } catch (error) {
            errors.push({
              message: `Failed to generate output ${output.name}: ${error instanceof Error ? error.message : 'Unknown error'}`,
              severity: 'error',
            });
          }
        }
      }

      // Handle modules (nested stacks)
      if (ir.modules.length > 0) {
        for (const module of ir.modules) {
          unsupportedFeatures.push({
            feature: 'modules',
            description: `Module "${module.name}" requires manual conversion to nested stack`,
          });
        }
      }

      if (errors.length > 0) {
        return {
          success: false,
          errors,
          warnings,
          unsupportedFeatures,
        };
      }

      // Convert to YAML
      const output = this.toYAML(cfTemplate);

      return {
        success: true,
        output,
        errors: [],
        warnings,
        unsupportedFeatures,
      };
    } catch (error) {
      return {
        success: false,
        errors: [
          {
            message: `Generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
            severity: 'error',
          },
        ],
        warnings: [],
        unsupportedFeatures: [],
      };
    }
  }

  format(output: string): string {
    // Basic formatting - ensure consistent line endings and trim
    return output.trim() + '\n';
  }

  /**
   * Generate CloudFormation parameter from IR variable
   */
  private generateParameter(variable: IRVariable): any {
    const param: any = {
      Type: this.mapVariableType(variable.valueType),
    };

    if (variable.description) {
      param.Description = variable.description;
    }

    if (variable.defaultValue !== undefined) {
      param.Default = this.convertValue(variable.defaultValue);
    }

    return param;
  }

  /**
   * Generate CloudFormation resource from IR resource
   */
  private generateResource(
    resource: IRResource,
    unsupportedFeatures: UnsupportedFeature[]
  ): any {
    const cfResource: any = {
      Type: this.mapResourceType(resource.resourceType, unsupportedFeatures),
      Properties: {},
    };

    // Convert properties
    for (const [key, value] of Object.entries(resource.properties)) {
      const cfKey = this.toCFPropertyName(key);
      cfResource.Properties[cfKey] = this.convertValue(value);
    }

    // Handle dependencies
    if (resource.dependsOn.length > 0) {
      cfResource.DependsOn = resource.dependsOn.map((dep) => this.toCFName(dep));
    }

    return cfResource;
  }

  /**
   * Generate CloudFormation output from IR output
   */
  private generateOutput(output: IROutput): any {
    const cfOutput: any = {
      Value: this.convertExpression(output.value),
    };

    if (output.description) {
      cfOutput.Description = output.description;
    }

    return cfOutput;
  }

  /**
   * Map Terraform resource type to CloudFormation resource type
   */
  private mapResourceType(
    terraformType: string,
    unsupportedFeatures: UnsupportedFeature[]
  ): string {
    // Basic mapping table
    const mappings: Record<string, string> = {
      aws_s3_bucket: 'AWS::S3::Bucket',
      aws_instance: 'AWS::EC2::Instance',
      aws_security_group: 'AWS::EC2::SecurityGroup',
      aws_vpc: 'AWS::EC2::VPC',
      aws_subnet: 'AWS::EC2::Subnet',
      aws_iam_role: 'AWS::IAM::Role',
      aws_lambda_function: 'AWS::Lambda::Function',
      aws_dynamodb_table: 'AWS::DynamoDB::Table',
      aws_rds_instance: 'AWS::RDS::DBInstance',
      aws_ecs_cluster: 'AWS::ECS::Cluster',
    };

    const mapped = mappings[terraformType];
    if (!mapped) {
      unsupportedFeatures.push({
        feature: `resource type: ${terraformType}`,
        description: `No direct mapping to CloudFormation, using generic type`,
      });
      return `Custom::${terraformType}`;
    }

    return mapped;
  }

  /**
   * Map variable type to CloudFormation parameter type
   */
  private mapVariableType(type: string): string {
    const mappings: Record<string, string> = {
      string: 'String',
      number: 'Number',
      list: 'CommaDelimitedList',
      map: 'String',
    };

    return mappings[type.toLowerCase()] || 'String';
  }

  /**
   * Convert IR value to CloudFormation value
   */
  private convertValue(value: IRValue): any {
    if (value === null || value === undefined) {
      return null;
    }

    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
      return value;
    }

    if (Array.isArray(value)) {
      return value.map((item) => this.convertValue(item));
    }

    if (this.isExpression(value)) {
      return this.convertExpression(value as IRExpression);
    }

    if (typeof value === 'object') {
      const result: any = {};
      for (const [key, val] of Object.entries(value)) {
        result[this.toCFPropertyName(key)] = this.convertValue(val);
      }
      return result;
    }

    return value;
  }

  /**
   * Convert IR expression to CloudFormation intrinsic function or reference
   */
  private convertExpression(expr: IRExpression): any {
    if (expr.exprType === 'literal') {
      return expr.value;
    }

    if (expr.exprType === 'reference') {
      return this.convertReference(expr.value);
    }

    if (expr.exprType === 'function') {
      return this.convertFunction(expr.value);
    }

    return expr.value;
  }

  /**
   * Convert Terraform reference to CloudFormation Ref or GetAtt
   */
  private convertReference(ref: string): any {
    // Handle variable references
    if (ref.startsWith('var.')) {
      const varName = ref.substring(4);
      return { Ref: this.toCFName(varName) };
    }

    // Handle resource attribute references (e.g., aws_s3_bucket.my_bucket.arn)
    const parts = ref.split('.');
    if (parts.length >= 2) {
      const resourceName = parts[1];
      if (parts.length === 2) {
        // Simple reference to resource
        return { Ref: this.toCFName(resourceName) };
      } else {
        // Attribute reference
        const attribute = parts.slice(2).join('.');
        return { 'Fn::GetAtt': [this.toCFName(resourceName), this.toCFAttributeName(attribute)] };
      }
    }

    // Fallback to simple ref
    return { Ref: this.toCFName(ref) };
  }

  /**
   * Convert Terraform function to CloudFormation intrinsic function
   */
  private convertFunction(func: any): any {
    // This is a simplified implementation
    // In a real implementation, you'd parse the function call and map it
    if (typeof func === 'string') {
      // Try to extract function name
      if (func.includes('join(')) {
        return { 'Fn::Join': ['', []] }; // Simplified
      }
      if (func.includes('concat(')) {
        return { 'Fn::Join': ['', []] }; // Simplified
      }
    }

    return func;
  }

  /**
   * Convert name to CloudFormation naming convention (PascalCase)
   */
  private toCFName(name: string): string {
    // Remove special characters and convert to PascalCase
    return name
      .split(/[_\-\.]/)
      .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Convert property name to CloudFormation property naming convention
   */
  private toCFPropertyName(name: string): string {
    // CloudFormation properties are PascalCase
    return this.toCFName(name);
  }

  /**
   * Convert attribute name to CloudFormation attribute name
   */
  private toCFAttributeName(attr: string): string {
    // Map common Terraform attributes to CloudFormation attributes
    const mappings: Record<string, string> = {
      arn: 'Arn',
      id: 'Ref',
      name: 'Name',
    };

    return mappings[attr] || this.toCFName(attr);
  }

  /**
   * Check if value is an expression
   */
  private isExpression(value: any): boolean {
    return (
      value &&
      typeof value === 'object' &&
      'exprType' in value &&
      'value' in value
    );
  }

  /**
   * Convert object to YAML format
   * This is a simplified YAML generator
   */
  private toYAML(obj: any, indent: number = 0): string {
    const spaces = '  '.repeat(indent);
    let yaml = '';

    if (obj === null || obj === undefined) {
      return 'null';
    }

    if (typeof obj === 'string') {
      // Check if string needs quoting
      if (obj.includes(':') || obj.includes('#') || obj.includes('\n')) {
        return `"${obj.replace(/"/g, '\\"')}"`;
      }
      return obj;
    }

    if (typeof obj === 'number' || typeof obj === 'boolean') {
      return String(obj);
    }

    if (Array.isArray(obj)) {
      if (obj.length === 0) {
        return '[]';
      }
      for (const item of obj) {
        yaml += `\n${spaces}- ${this.toYAML(item, indent + 1)}`;
      }
      return yaml;
    }

    if (typeof obj === 'object') {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        const valueYaml = this.toYAML(value, indent + 1);

        if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
          yaml += `\n${spaces}${key}:${valueYaml}`;
        } else if (Array.isArray(value)) {
          yaml += `\n${spaces}${key}:${valueYaml}`;
        } else {
          yaml += `\n${spaces}${key}: ${valueYaml}`;
        }
      }
      return yaml;
    }

    return String(obj);
  }
}
